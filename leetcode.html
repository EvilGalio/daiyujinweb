<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>随笔</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism.css">
    <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-python.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-javascript.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-kotlin.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&family=Fira+Code&display=swap" rel="stylesheet">
</head>

<body>
    <div class="container">
        <nav>
            <div><strong>DaiyujinCoding</strong></div>
            <div>
                <a href="index.html">首页</a>
                <a href="about.html">关于</a>
            </div>
        </nav>
    <div class="article">
        <h1>雨尽随笔</h1>
        <p><small>2025-08-22创建</small></p>
        <h2>写在最前</h2>
        <p>我不是写代码的高手，我甚至常常一行写完就怀疑自己。这里的内容不是自得自满，而是我记录自己跌跌撞撞留下的痕迹。若你看见这些代码觉得可笑，请你原谅我的笨拙，再顺手告诉我哪里错了，我会心怀感激。</p>
        <h2>155:最小栈</h2>
        <p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>
        <p>实现 <code>MinStack</code> 类:</p>
        <ul>
            <li><code>MinStack()</code> 初始化堆栈对象。</li>
            <li><code>void push(int val)</code> 将元素val推入堆栈。</li>
            <li><code>void pop()</code> 删除堆栈顶部的元素。</li>
            <li><code>int top()</code> 获取堆栈顶部的元素。</li>
            <li><code>int getMin()</code> 获取堆栈中的最小元素。</li>
        </ul>
        <h3>题解</h3>
        <pre><code class="language-python">class MinStack:
            def __init__(self):
                self.stack=[]
                self.min = [2**31]
            def push(self, val: int) -> None:
                self.stack.append(val)
                self.min.append(min(val,self.min[-1]))
            def pop(self) -> None:
                self.stack.pop()
                self.min.pop()
            def top(self) -> int:
                top=self.stack[-1]
                return top
        
            def getMin(self) -> int:
                return self.min[-1]
        </code></pre>
        
        <h2>20:有效的括号</h2>
        <p>给定一个只包括
            <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code>
            的字符串 <code>s</code> ，判断字符串是否有效。</p>
        <p>有效字符串需满足：</p>
        <ol>
            <li>左括号必须用相同类型的右括号闭合。</li>
            <li>左括号必须以正确的顺序闭合。</li>
            <li>每个右括号都有一个对应的相同类型的左括号。</li>
        </ol>
        <h3>题解</h3>
        <pre><code class="language-python">class Solution:
            def isValid(self, s: str) -> bool:
                list=[]
                for str in s:
                    list.append(str)
                def jud(a,b):
                    if a=='('and b==')':
                        return True
                    elif a=='['and b==']':
                        return True
                    elif a=='{' and b== '}':
                        return True
                    else:return False
                def syn(list):
                    if len(list)==0:
                        return True
                    elif len(list)%2 !=0:
                        return False
                    else: 
                        i=0
                        while i<=len(list)/2:
                            if list[i] in ['[','(','{']:
                                i+=1
                                continue
                            elif list[i] in [')',']','}']:
                                if jud(list[i-1],list[i]) and i!=0:
                                    list.pop(i)
                                    list.pop(i-1)
                                    return syn(list)
                                else:
                                    return False
                        return False
                return syn(list)
        </code></pre>
        
        <h2>169：多数元素</h2>
        <p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。
        </p>
        <p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
        <pre><code class="language-python">class Solution:
            def majorityElement(self, nums: List[int]) -> int:
                n = len(nums)
                result = 0
                for i in set(nums):
                    coun = nums.count(i)
                    if coun >n/2:
                        result = i
                        break
                return result
        </code></pre>
    </div>
<h2>239：滑动窗口最大值——单调队列</h2>
<p>给你一个整数数组 <code class="language-none">nums</code>，有一个大小为 <code class="language-none">k</code>
    的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code class="language-none">k</code> 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 <em>滑动窗口中的最大值</em> 。</p>
<p><strong>示例 1：</strong></p>

<p>输入：<code class="language-none">nums = [1,3,-1,-3,5,3,6,7], k = 3</code><br>
    输出：<br>
    解释：<br>
    滑动窗口的位置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最大值</p>
<hr>
<pre><code class="language-none">[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
</code></pre>

<p><strong>示例 2：</strong></p>
<p>输入：<code class="language-none">nums = [1], k = 1</code><br>输出：<code class="language-none">1</code></p>

<p>我自己的最初的解法是最原始的暴力解法，最后不出意外的报了 TimeOutError。参考了
    <a href="https://leetcode.cn/u/jyd/" target="_blank" rel="noopener noreferrer">Krahets</a> 的题解，自己实现了
    <strong>单调队列</strong> 来重新解。
</p>

<pre><code class="language-python">from typing import List
import collections

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:
        res = []
        dq = collections.deque()  # 存放“值”的单调递减队列
        n = len(nums)
        for i, j in zip(range(1 - k, n - k + 1), range(n)):
            # 如果队首等于滑出窗口的元素，则从左侧弹出（完成“滑动”）
            if i &gt;= 0 and dq and dq[0] == nums[i]:
                dq.popleft()
            # 保持队列单调：把所有比新元素小的从右侧弹出
            while dq and dq[-1] &lt; nums[j]:
                dq.pop()
            dq.append(nums[j])
            res.append(dq[0])  # 队首即当前窗口最大值
        return res[k - 1:]
</code></pre>

<p>虽然最后成功通过，但只是狗尾续貂罢了，很佩服提出这个算法的大神。</p>

<hr>

<h2>104：二叉树的最大深度</h2>
<p>给定一个二叉树 <code class="language-none">root</code> ，返回其最大深度。</p>
<p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p>

<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="img"></p>
<pre><code class="language-none">输入：root = [3,9,20,null,null,15,7]
输出：3
</code></pre>

<p><strong>示例 2：</strong></p>
<pre><code class="language-none">输入：root = [1,null,2]
输出：2
</code></pre>

<p>这个题的难度是简单，但这是我第一次接触树这个数据结构。思来想去，我的思路是使用 DFS（深度优先搜索）方法，获得所有叶子节点的深度，最后再获得最大值。</p>

<pre><code class="language-python">from typing import Optional, List

class Solution:
    class TreeNode:
        def __init__(self, val: int = 0, left: 'Solution.TreeNode' = None, right: 'Solution.TreeNode' = None):
            self.val = val
            self.left = left
            self.right = right

    def maxDepth(self, root: Optional['Solution.TreeNode']) -&gt; int:
        res: List[int] = []  # 记录所有叶子节点的深度

        def dfs(node: Optional['Solution.TreeNode'], depth: int = 1) -&gt; None:
            if not node:  # 空节点
                return
            if not node.left and not node.right:  # 叶子节点
                res.append(depth)
                return
            if node.left:
                dfs(node.left, depth + 1)
            if node.right:
                dfs(node.right, depth + 1)

        if not root:
            return 0  # 空树深度为 0
        dfs(root, 1)
        return max(res) if res else 0
</code></pre>



            <footer>
                © 2025 Daiyujin All rights resserved | <a >页面最后更新日期：2025-08-25</a>
            </footer>
            </div>
            </body>
            
            </html>